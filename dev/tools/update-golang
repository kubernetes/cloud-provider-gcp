#!/usr/bin/env python3
import json
import os
import urllib.request
import subprocess
import re
import argparse

# The file paths to update.
# Assumes the script is run from the root of the repository.
WORKSPACE_PATH = "WORKSPACE"

def find_go_files():
    """Finds all go.mod and go.work files in the repository."""
    go_files = []
    for root, dirs, files in os.walk("."):
        # Prune directories we don't want to search
        dirs[:] = [d for d in dirs if not d.startswith(".") and d not in ["vendor", "_tmp", "_artifacts", "_rundir"] and not d.startswith("bazel-")]
        for file in files:
            if file in ["go.mod", "go.work"]:
                go_files.append(os.path.join(root, file))
    return go_files

def find_dockerfiles():
    """Finds all Dockerfiles in the repository."""
    dockerfile_files = []
    for root, dirs, files in os.walk("."):
        dirs[:] = [d for d in dirs if not d.startswith(".") and d not in ["vendor", "_tmp", "_artifacts", "_rundir"] and not d.startswith("bazel-")]
        if "Dockerfile" in files:
            dockerfile_files.append(os.path.join(root, "Dockerfile"))
    return dockerfile_files

def get_latest_go_version():
    """Fetches the latest stable Go version from the official Go website."""
    url = "https://go.dev/dl/?mode=json"
    print(f"Fetching latest Go versions from {url}...")
    with urllib.request.urlopen(url) as response:
        if response.status != 200:
            raise RuntimeError(f"Failed to fetch Go versions: HTTP {response.status}")
        releases = json.loads(response.read().decode())

    for release in releases:
        if release["stable"]:
            version = release["version"].replace("go", "")
            print(f"Latest stable Go version is {version}")
            return version
    raise RuntimeError("Could not find a stable Go release.")

def _replace_file_contents(file_path, fn):
    """Replaces the contents of a file with the result of a function, applied line-by-line."""
    if not os.path.exists(file_path):
        raise FileNotFoundError(f"Could not find file at {file_path}")
    
    with open(file_path, "r") as f:
        lines = f.readlines()

    count = 0
    updated_lines = []
    for line in lines:
        new_line = fn(line)
        if new_line != line:
            count += 1
        updated_lines.append(new_line)

    if count == 0:
        print(f"No changes made to {file_path}.")
        return

    with open(file_path, "w") as f:
        f.writelines(updated_lines)
    print(f"Successfully updated {file_path}")

def update_go_file(file_path, new_version):
    """Updates the go and toolchain directives in a go.mod or go.work file."""
    def fn(line):
        stripped = line.lstrip()
        # Replace lines like `go 1.22.3`
        if stripped.startswith("go "):
            return f"go {new_version}\n"
        # Replace lines like `toolchain go1.22.3`
        if stripped.startswith("toolchain go"):
            return f"toolchain go{new_version}\n"
        return line

    _replace_file_contents(file_path, fn)


def update_bazel_workspace(file_path, go_version):
    """Updates the Go SDK version in the WORKSPACE file."""
    def fn(line):
        # Replace lines like `go_download_sdk(name = "go_sdk",version = "1.24.1")`
        if "go_download_sdk(" in line and "version =" in line:
            return re.sub(r'version = "[0-9.]+"', f'version = "{go_version}"', line)
        return line

    _replace_file_contents(file_path, fn)

def update_dockerfile(file_path, go_version):
    """Updates the Go version in the Dockerfile."""
    def fn(line):
        # Replace lines like `FROM golang:1.24.1` or `FROM --platform=... golang:1.24.1 AS builder`
        if line.lstrip().startswith("FROM ") and "golang:" in line:
            return re.sub(r"golang:[0-9.]+", f"golang:{go_version}", line)
        return line

    _replace_file_contents(file_path, fn)


def main():
    """
    Main function to orchestrate the update process.
    1. Fetches (or receives) the Go version to update to.
    2. Updates all go.mod and go.work files.
    3. Updates all Dockerfiles.
    4. Updates the WORKSPACE file.
    5. Verifies the updates with 'go mod tidy' and 'bazel sync'.
    """
    parser = argparse.ArgumentParser(description="Update Go version across the repository.")
    parser.add_argument("--version", help="The Go version to update to (e.g., 1.25.7). If not specified, fetches the latest stable version.")
    args = parser.parse_args()

    if args.version:
        target_version = args.version.replace("go", "")
        print(f"Targeting Go version {target_version} (specified via --version)")
    else:
        target_version = get_latest_go_version()

    env = os.environ.copy()
    env["GOTOOLCHAIN"] = "auto"

    # 1. Update all files first to ensure consistency
    go_files = find_go_files()
    for go_path in go_files:
        update_go_file(go_path, target_version)

    for dockerfile_path in find_dockerfiles():
        update_dockerfile(dockerfile_path, target_version)

    update_bazel_workspace(WORKSPACE_PATH, target_version)

    # 2. Run verification commands
    for go_path in go_files:
        if go_path.endswith("go.mod"):
            print(f"Running go mod tidy for {go_path}")
            subprocess.run(["go", "mod", "tidy"], cwd=os.path.dirname(go_path) or ".", check=True, env=env)

    print("Running bazel sync...")
    subprocess.run(["bazel", "sync"], check=True, env=env)

    print(f"\nGo version update to {target_version} complete!")

if __name__ == "__main__":
    # Ensure the script is run from the repository root
    if not os.path.exists(WORKSPACE_PATH):
        print(f"Error: This script must be run from the repository root directory containing the WORKSPACE file.")
    else:
        main()
